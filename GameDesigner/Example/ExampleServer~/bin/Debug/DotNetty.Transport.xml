<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetty.Transport</name>
    </assembly>
    <members>
        <member name="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2">
            <summary>
            This is a helper class that makes it easy to bootstrap an <see cref="T:DotNetty.Transport.Channels.IChannel"/>. It supports method-
            chaining to provide an easy way to configure the <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/>.
            
            When not used in a <see cref="T:DotNetty.Transport.Bootstrapping.ServerBootstrap"/> context, the <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.EndPoint)"/> methods
            are useful for connectionless transports such as datagram (UDP).
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Group(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Specifies the <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which will handle events for the <see cref="T:DotNetty.Transport.Channels.IChannel"/> being built.
            </summary>
            <param name="group">The <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which is used to handle all the events for the to-be-created <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Channel``1">
            <summary>
            Specifies the <see cref="T:System.Type"/> of <see cref="T:DotNetty.Transport.Channels.IChannel"/> which will be created.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> which is used to create <see cref="T:DotNetty.Transport.Channels.IChannel"/> instances from.</typeparam>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.EndPoint)">
            <summary>
            Assigns the <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> instance to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Int32)">
            <summary>
            Assigns the local <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for any IP address on the local machine, given a specific port.
            </summary>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.String,System.Int32)">
            <summary>
            Assigns the local <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            This overload binds to a <see cref="T:System.Net.DnsEndPoint"/> for a given hostname and port.
            </summary>
            <param name="inetHost">The hostname to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            Assigns the local <see cref="T:System.Net.EndPoint"/> which is used to bind the local "end" to.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for a given <see cref="T:System.Net.IPAddress"/> and port.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Option``1(DotNetty.Transport.Channels.ChannelOption{``0},``0)">
            <summary>
            Allows the specification of a <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> which is used for the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> instances once they get created. Use a value of <c>null</c> to remove
            a previously set <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/>.
            </summary>
            <param name="option">The <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> to configure.</param>
            <param name="value">The value to set the given option.</param>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Attribute``1(DotNetty.Common.Utilities.AttributeKey{``0},``0)">
            <summary>
            Allows specification of an initial attribute of the newly created <see cref="T:DotNetty.Transport.Channels.IChannel" />. If the <c>value</c> is
            <c>null</c>, the attribute of the specified <c>key</c> is removed.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Validate">
            <summary>
            Validates all the parameters. Sub-classes may override this, but should call the super method in that case.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Clone">
            <summary>
            Returns a deep clone of this bootstrap which has the identical configuration.  This method is useful when making
            multiple <see cref="T:DotNetty.Transport.Channels.IChannel"/>s with similar settings.  Please note that this method does not clone the
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> deeply but shallowly, making the group a shared resource.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.RegisterAsync">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and registers it with an <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it to the endpoint specified via the <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.EndPoint)"/> methods.
            </summary>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for any IP address on the local machine, given a specific port.
            </summary>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.String,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            This overload binds to a <see cref="T:System.Net.DnsEndPoint"/> for a given hostname and port.
            </summary>
            <param name="inetHost">The hostname to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            This overload binds to a <see cref="T:System.Net.IPEndPoint"/> for a given <see cref="T:System.Net.IPAddress"/> and port.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> to bind the local "end" to.</param>
            <param name="inetPort">The port to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.EndPoint)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> and binds it.
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> instance to bind the local "end" to.</param>
            <returns>The bound <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Handler(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Specifies the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to use for serving the requests.
            </summary>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to use for serving requests.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Group">
            <summary>
            Returns the configured <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> or <c>null</c> if none is configured yet.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Bootstrapping.Bootstrap">
            <summary>
            A <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that makes it easy to bootstrap an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to use for clients.
            
            The <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.EndPoint)"/> methods are useful
            in combination with connectionless transports such as datagram (UDP). For regular TCP connections,
            please use the provided <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)"/> methods.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.Resolver(DotNetty.Transport.Bootstrapping.INameResolver)">
            <summary>
            Sets the <see cref="T:DotNetty.Transport.Bootstrapping.INameResolver"/> which will resolve the address of the unresolved named address.
            </summary>
            <param name="resolver">The <see cref="T:DotNetty.Transport.Bootstrapping.INameResolver"/> which will resolve the address of the unresolved named address.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.Net.EndPoint)">
            <summary>
            Assigns the remote <see cref="T:System.Net.EndPoint"/> to connect to once the <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/> method is called.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.String,System.Int32)">
            <summary>
            Assigns the remote <see cref="T:System.Net.EndPoint"/> to connect to once the <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/> method is called.
            </summary>
            <param name="inetHost">The hostname of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            Assigns the remote <see cref="T:System.Net.EndPoint"/> to connect to once the <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/> method is called.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.String,System.Int32)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="inetHost">The hostname of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="inetHost">The <see cref="T:System.Net.IPAddress"/> of the endpoint to connect to.</param>
            <param name="inetPort">The port at the remote host to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Connects an <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the remote peer.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The local <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.DoResolveAndConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Performs DNS resolution for the remote endpoint and connects to it.
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The local <see cref="T:System.Net.EndPoint"/> to connect the remote to.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.Bootstrap.Clone(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Returns a deep clone of this bootstrap which has the identical configuration except that it uses
            the given <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>. This method is useful when making multiple <see cref="T:DotNetty.Transport.Channels.IChannel"/>s with similar
            settings.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Bootstrapping.ServerBootstrap">
            <summary>
            A <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> sub-class which allows easy bootstrapping of <see cref="T:DotNetty.Transport.Channels.IServerChannel"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.Group(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Specifies the <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which is used for the parent (acceptor) and the child (client).
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.Group(DotNetty.Transport.Channels.IEventLoopGroup,DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Sets the <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> for the parent (acceptor) and the child (client). These
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>'s are used to handle all the events and IO for <see cref="T:DotNetty.Transport.Channels.IServerChannel"/>
            and <see cref="T:DotNetty.Transport.Channels.IChannel"/>'s.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildOption``1(DotNetty.Transport.Channels.ChannelOption{``0},``0)">
            <summary>
            Allows specification of a <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> which is used for the <see cref="T:DotNetty.Transport.Channels.IChannel"/>
            instances once they get created (after the acceptor accepted the <see cref="T:DotNetty.Transport.Channels.IChannel"/>). Use a
            value of <c>null</c> to remove a previously set <see cref="T:DotNetty.Transport.Channels.ChannelOption"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildAttribute``1(DotNetty.Common.Utilities.AttributeKey{``0},``0)">
            <summary>
            Sets the specific <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/> with the given value on every child <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            If the value is <c>null</c>, the <see cref="T:DotNetty.Common.Utilities.AttributeKey`1"/> is removed.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildHandler(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Sets the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> which is used to serve the request for the <see cref="T:DotNetty.Transport.Channels.IChannel"/>'s.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildGroup">
            <summary>
            Returns the configured <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> which will be used for the child channels or <c>null</c>
            if none is configured yet.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannel.strValActive">
            <summary>Cache for the string representation of this channel</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.#ctor(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="parent">The parent of this channel. Pass <c>null</c> if there's no parent.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.#ctor(DotNetty.Transport.Channels.IChannel,DotNetty.Transport.Channels.IChannelId)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="parent">The parent of this channel. Pass <c>null</c> if there's no parent.</param>
            <param name="id">An <see cref="T:DotNetty.Transport.Channels.IChannelId"/> for the new channel.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.InvalidateRemoteAddress">
            <summary>
            Resets the stored <see cref="P:DotNetty.Transport.Channels.AbstractChannel.RemoteAddress"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.NewId">
            <summary>
            Returns a new <see cref="T:DotNetty.Transport.Channels.DefaultChannelId"/> instance. Subclasses may override this method to assign custom
            <see cref="T:DotNetty.Transport.Channels.IChannelId"/>s to <see cref="T:DotNetty.Transport.Channels.IChannel"/>s that use the <see cref="T:DotNetty.Transport.Channels.AbstractChannel"/> constructor.
            </summary>
            <returns>A new <see cref="T:DotNetty.Transport.Channels.DefaultChannelId"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.NewChannelPipeline">
            <summary>Returns a new pipeline instance.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.NewUnsafe">
            <summary>
            Create a new <see cref="T:DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe" /> instance which will be used for the life-time of the
            <see cref="T:DotNetty.Transport.Channels.IChannel" />
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.GetHashCode">
            <summary>
            Returns the ID of this channel.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.Equals(System.Object)">
            <summary>
            Returns <c>true</c> if and only if the specified object is identical
            with this channel (i.e. <c>this == o</c>).
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.ToString">
            <summary>
            Returns the string representation of this channel. The returned string contains a hex dump of the
            <see cref="T:DotNetty.Transport.Channels.IChannelId"/>, the <see cref="P:DotNetty.Transport.Channels.AbstractChannel.LocalAddress"/>, and the <see cref="P:DotNetty.Transport.Channels.AbstractChannel.RemoteAddress"/> of this
            channel for easier identification.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IChannelUnsafe" /> implementation which sub-classes must extend and use.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe.neverRegistered">
            <summary> true if the channel has never been registered, false otherwise /// </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe.DeregisterAsync">
            <summary>
            This method must NEVER be called directly, but be executed as an
            extra task with a clean call stack instead. The reason for this
            is that this method calls <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelUnregistered"/>
            directly, which might lead to an unfortunate nesting of independent inbound/outbound
            events. See the comments input <see cref="M:DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe.InvokeLater(System.Action)"/> for more details.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe.PrepareToClose">
            <summary>
            Prepares to close the <see cref="T:DotNetty.Transport.Channels.IChannel"/>. If this method returns an <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>, the
            caller must call the <see cref="!:IEventExecutor.Execute(DotNetty.Common.Concurrency.IRunnable)"/> method with a task that calls
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel.DoClose"/> on the returned <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>. If this method returns <c>null</c>,
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel.DoClose"/> must be called from the caller thread. (i.e. <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>)
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.IsCompatible(DotNetty.Transport.Channels.IEventLoop)">
            <summary>
            Checks whether a given <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is compatible with the <see cref="T:DotNetty.Transport.Channels.AbstractChannel"/>.
            </summary>
            <param name="eventLoop">The <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> to check compatibility.</param>
            <returns>
            <c>true</c> if the given <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is compatible with this <see cref="T:DotNetty.Transport.Channels.AbstractChannel"/>
            instance, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.DoRegister">
            <summary>
            Is called after the <see cref="T:DotNetty.Transport.Channels.IChannel"/> is registered with its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> as part of the
            register process. Sub-classes may override this method.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.DoBind(System.Net.EndPoint)">
            <summary>
            Binds the <see cref="T:DotNetty.Transport.Channels.IChannel"/> to the <see cref="T:System.Net.EndPoint"/>.
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to bind.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.DoDisconnect">
            <summary>
            Disconnects this <see cref="T:DotNetty.Transport.Channels.IChannel"/> from its remote peer.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.DoClose">
            <summary>
            Closes the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.DoDeregister">
            <summary>
            Deregisters the <see cref="T:DotNetty.Transport.Channels.IChannel"/> from its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>. Sub-classes may override this
            method.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.DoBeginRead">
            <summary>
            ScheduleAsync a read operation.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)">
            <summary>
            Flush the content of the given buffer to the remote peer.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractChannel.FilterOutboundMessage(System.Object)">
            <summary>
            Invoked when a new message is added to a <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/> of this
            <see cref="T:DotNetty.Transport.Channels.AbstractChannel"/>, so that the <see cref="T:DotNetty.Transport.Channels.IChannel"/> implementation converts the message to
            another. (e.g. heap buffer -> direct buffer).
            </summary>
            <param name="msg">The message to be filtered.</param>
            <returns>The filtered message.</returns>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannelHandlerContext.HandlerState.Init">
            <summary>Neither <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)"/> nor <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)"/> was called.</summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannelHandlerContext.HandlerState.Added">
            <summary><see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)"/> was called.</summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.AbstractChannelHandlerContext.HandlerState.Removed">
            <summary><see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)"/> was called.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.AbstractChannelHandlerContext.Added">
            <summary>
                Makes best possible effort to detect if <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)" /> was
                called
                yet. If not return <c>false</c> and if called or could not detect return <c>true</c>.
                If this method returns <c>true</c> we will not invoke the <see cref="T:DotNetty.Transport.Channels.IChannelHandler" /> but just forward the
                event.
                This is needed as <see cref="T:DotNetty.Transport.Channels.DefaultChannelPipeline" /> may already put the <see cref="T:DotNetty.Transport.Channels.IChannelHandler" /> in the
                linked-list
                but not called
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.AbstractServerChannel">
            <summary>
            A skeletal server-side <see cref="T:DotNetty.Transport.Channels.IChannel"/> implementation. A server-side <see cref="T:DotNetty.Transport.Channels.IChannel"/> does not
            allow the following operations: <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)"/>,
            <see cref="M:DotNetty.Transport.Channels.IChannel.DisconnectAsync"/>, <see cref="M:DotNetty.Transport.Channels.IChannel.WriteAsync(System.Object)"/>,
            <see cref="M:DotNetty.Transport.Channels.IChannel.Flush"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AbstractServerChannel.#ctor">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.AdaptiveRecvByteBufAllocator">
            <summary>
                The <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocator" /> that automatically increases and
                decreases the predicted buffer size on feed back.
                <p />
                It gradually increases the expected number of readable bytes if the previous
                read fully filled the allocated buffer. It gradually decreases the expected
                number of readable bytes if the read operation was not able to fill a certain
                amount of the allocated buffer two times consecutively. Otherwise, it keeps
                returning the same prediction.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AdaptiveRecvByteBufAllocator.#ctor">
            <summary>
                Creates a new predictor with the default parameters.  With the default
                parameters, the expected buffer size starts from <c>1024</c>, does not
                go down below <c>64</c>, and does not go up above <c>65536</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AdaptiveRecvByteBufAllocator.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Creates a new predictor with the specified parameters.</summary>
            <param name="minimum">the inclusive lower bound of the expected buffer size</param>
            <param name="initial">the initial buffer size when no feed back was received</param>
            <param name="maximum">the inclusive upper bound of the expected buffer size</param>
        </member>
        <member name="T:DotNetty.Transport.Channels.AffinitizedEventLoopGroup">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> that works as a wrapper for another <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> providing affinity on <see cref="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.GetNext"/> call.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.TerminationCompletion">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>
        </member>
        <member name="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.#ctor(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Creates a new instance of <see cref="T:DotNetty.Transport.Channels.AffinitizedEventLoopGroup"/>.
            </summary>
            <param name="innerGroup"><see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> serving as an actual provider of <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>s.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.GetNext">
            <summary>
            If running in a context of an existing <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>, this <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is returned.
            Otherwise, <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> is retrieved from underlying <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.AffinitizedEventLoopGroup.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/>
        </member>
        <member name="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue">
            <summary>
                A queue of write operations which are pending for later execution. It also updates the
                <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable">writability</see> of the associated <see cref="T:DotNetty.Transport.Channels.IChannel" />, so that
                the pending write operations are also considered to determine the writability.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.BatchingPendingWriteQueue.IsEmpty">
            <summary>Returns <c>true</c> if there are no pending write operations left in this queue.</summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Size">
            <summary>Returns the number of pending write operations.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Add(System.Object)">
            <summary>Add the given <c>msg</c> and returns <see cref="T:System.Threading.Tasks.Task" /> for completion of processing <c>msg</c>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndFailAll(System.Exception)">
            <summary>
                Remove all pending write operation and fail them with the given <see cref="T:System.Exception" />. The messages will be
                released
                via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndFail(System.Exception)">
            <summary>
                Remove a pending write operation and fail it with the given <see cref="T:System.Exception" />. The message will be released
                via
                <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndWriteAllAsync">
            <summary>
                Remove all pending write operation and performs them via
                <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object)" />.
            </summary>
            <returns>
                <see cref="T:System.Threading.Tasks.Task" /> if something was written and <c>null</c> if the <see cref="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue" />
                is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.RemoveAndWriteAsync">
            <summary>
                Removes a pending write operation and performs it via
                <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object)"/>.
            </summary>
            <returns>
                <see cref="T:System.Threading.Tasks.Task" /> if something was written and <c>null</c> if the <see cref="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue" />
                is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Remove">
            <summary>
                Removes a pending write operation and release it's message via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <returns><see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource" /> of the pending write or <c>null</c> if the queue is empty.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.BatchingPendingWriteQueue.Current">
            <summary>
                Return the current message or <c>null</c> if empty.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.BatchingPendingWriteQueue.PendingWrite">
            <summary>Holds all meta-data and construct the linked-list structure.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.ChannelDuplexHandler">
            <summary>
            It is a good starting point if your <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> implementation needs to intercept operations and also
            state updates.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.ChannelInitializer`1">
            <summary>
            A special <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> which offers an easy way to initialize a <see cref="T:DotNetty.Transport.Channels.IChannel"/> once it was
            registered to its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            <para>
            Implementations are most often used in the context of <see cref="M:DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Handler(DotNetty.Transport.Channels.IChannelHandler)"/>
            and <see cref="M:DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildHandler(DotNetty.Transport.Channels.IChannelHandler)"/> to setup the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of a <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            Be aware that this class is marked as Sharable (via <see cref="P:DotNetty.Transport.Channels.ChannelInitializer`1.IsSharable"/>) and so the implementation must be safe to be re-used.
            </summary>
            <example>
            <code>
            public class MyChannelInitializer extends <see cref="T:DotNetty.Transport.Channels.ChannelInitializer`1"/> {
                public void InitChannel(<see cref="T:DotNetty.Transport.Channels.IChannel"/> channel) {
                    channel.Pipeline().AddLast("myHandler", new MyHandler());
                }
            }
            <see cref="T:DotNetty.Transport.Bootstrapping.ServerBootstrap"/> bootstrap = ...;
            ...
            bootstrap.childHandler(new MyChannelInitializer());
            ...
            </code>
            </example>
            <typeparam name="T">A sub-type of <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</typeparam>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelInitializer`1.InitChannel(`0)">
            <summary>
            This method will be called once the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was registered. After the method returns this instance
            will be removed from the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> which was registered.</param>
        </member>
        <member name="T:DotNetty.Transport.Channels.ChannelMetadata">
            <summary>Represents the properties of a <see cref="T:DotNetty.Transport.Channels.IChannel" /> implementation.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelMetadata.#ctor(System.Boolean)">
            <summary>Create a new instance</summary>
            <param name="hasDisconnect">
                <c>true</c> if and only if the channel has the <c>DisconnectAsync()</c> operation
                that allows a user to disconnect and then call <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)" />
                again, such as UDP/IP.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelMetadata.#ctor(System.Boolean,System.Int32)">
            <summary>Create a new instance</summary>
            <param name="hasDisconnect">
                <c>true</c> if and only if the channel has the <c>DisconnectAsync</c> operation
                that allows a user to disconnect and then call <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)" />
                again, such as UDP/IP.
            </param>
            <param name="defaultMaxMessagesPerRead">
                If a <see cref="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator" /> is in use, then this value will be
                set for <see cref="P:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator.MaxMessagesPerRead" />. Must be <c> &gt; 0</c>.
            </param>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelMetadata.HasDisconnect">
            <summary>
                Returns <c>true</c> if and only if the channel has the <c>DisconnectAsync()</c> operation
                that allows a user to disconnect and then call <see cref="M:DotNetty.Transport.Channels.IChannel.ConnectAsync(System.Net.EndPoint)" /> again,
                such as UDP/IP.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelMetadata.DefaultMaxMessagesPerRead">
            <summary>
                If a <see cref="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator" /> is in use, then this is the default value for
                <see cref="P:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator.MaxMessagesPerRead" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.ValueOf``1(System.String)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> of the specified name.
            </summary>
            <typeparam name="T">The type of option being retrieved.</typeparam>
            <param name="name">The name of the desired option.</param>
            <returns>The matching <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.ValueOf``1(System.Type,System.String)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> of the given pair: (<see cref="T:System.Type"/>, secondary name)
            </summary>
            <typeparam name="T">The type of option being retrieved.</typeparam>
            <param name="firstNameComponent">
            A <see cref="T:System.Type"/> whose name will be used as the first part of the desired option's name.
            </param>
            <param name="secondNameComponent">
            A string representing the second part of the desired option's name.
            </param>
            <returns>The matching <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.Exists(System.String)">
            <summary>
            Checks whether a given <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> exists.
            </summary>
            <param name="name">The name of the <see cref="T:DotNetty.Transport.Channels.ChannelOption"/>.</param>
            <returns><c>true</c> if a <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> exists for the given <paramref name="name"/>, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOption.NewInstance``1(System.String)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> for the given <paramref name="name"/>.
            </summary>
            <typeparam name="T">The type of option to create.</typeparam>
            <param name="name">The name to associate with the new option.</param>
            <exception cref="T:System.ArgumentException">Thrown if a <see cref="T:DotNetty.Transport.Channels.ChannelOption"/> for the given <paramref name="name"/> exists.</exception>
            <returns>The new <see cref="T:DotNetty.Transport.Channels.ChannelOption`1"/> instance.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.AddMessage(System.Object,System.Int32,DotNetty.Common.Concurrency.TaskCompletionSource)">
            <summary>
            Adds the given message to this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>. The given
            <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> will be notified once the message was written.
            </summary>
            <param name="msg">The message to add to the buffer.</param>
            <param name="size">The size of the message.</param>
            <param name="promise">The <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> to notify once the message is written.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.AddFlush">
            <summary>
            Add a flush to this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>. This means all previous added messages are marked
            as flushed and so you will be able to handle them.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IncrementPendingOutboundBytes(System.Int64)">
            <summary>
            Increments the number of pending bytes which will be written at some point.
            This method is thread-safe!
            </summary>
            <param name="size">The number of bytes to increment the count by.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.DecrementPendingOutboundBytes(System.Int64)">
            <summary>
            Decrements the number of pending bytes which will be written at some point.
            This method is thread-safe!
            </summary>
            <param name="size">The number of bytes to decrement the count by.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.Current">
            <summary>
            Returns the current message to write, or <c>null</c> if nothing was flushed before and so is ready to be
            written.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.Progress(System.Int64)">
            <summary>
            Notify the <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> of the current message about writing progress.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.Remove">
            <summary>
            Removes the current message, marks its <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> as complete, and returns
            <c>true</c>. If no flushed message exists at the time this method is called, it returns <c>false</c> to
            signal that no more messages are ready to be handled.
            </summary>
            <returns><c>true</c> if a message existed and was removed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.Remove(System.Exception)">
            <summary>
            Removes the current message, marks its <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> as complete using the given
            <see cref="T:System.Exception"/>, and returns <c>true</c>. If no flushed message exists at the time this method is
            called, it returns <c>false</c> to signal that no more messages are ready to be handled.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> causing the message to be removed.</param>
            <returns><c>true</c> if a message existed and was removed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.RemoveBytes(System.Int64)">
            <summary>
            Removes the fully written entries and updates the reader index of the partially written entry.
            This operation assumes all messages in this buffer are <see cref="T:DotNetty.Buffers.IByteBuffer"/> instances.
            </summary>
            <param name="writtenBytes">The number of bytes that have been written so far.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.ClearNioBuffers">
            <summary>
            Clears all ByteBuffer from the array so these can be GC'ed.
            See https://github.com/netty/netty/issues/3837
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList">
            <summary>
            Returns a list of direct ArraySegment&lt;byte&gt;, if the currently pending messages are made of
            <see cref="T:DotNetty.Buffers.IByteBuffer"/> instances only. <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.NioBufferSize"/> will return the total number of
            readable bytes of these buffers.
            <para>
            Note that the returned array is reused and thus should not escape
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/>. Refer to
            <see cref="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/> for an example.
            </para>
            </summary>
            <returns>A list of ArraySegment&lt;byte&gt; buffers.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList(System.Int32,System.Int64)">
            <summary>
            Returns a list of direct ArraySegment&lt;byte&gt;, if the currently pending messages are made of
            <see cref="T:DotNetty.Buffers.IByteBuffer"/> instances only. <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.NioBufferSize"/> will return the total number of
            readable bytes of these buffers.
            <para>
            Note that the returned array is reused and thus should not escape
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/>. Refer to
            <see cref="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.DoWrite(DotNetty.Transport.Channels.ChannelOutboundBuffer)"/> for an example.
            </para>
            </summary>
            <param name="maxCount">The maximum amount of buffers that will be added to the return value.</param>
            <param name="maxBytes">A hint toward the maximum number of bytes to include as part of the return value. Note that this value maybe exceeded because we make a best effort to include at least 1 <see cref="T:DotNetty.Buffers.IByteBuffer"/> in the return value to ensure write progress is made.</param>
            <returns>A list of ArraySegment&lt;byte&gt; buffers.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.NioBufferSize">
            <summary>
            Returns the number of bytes that can be written out of the <see cref="T:DotNetty.Buffers.IByteBuffer"/> array that was
            obtained via <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList"/>. This method <strong>MUST</strong> be called after
            <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetSharedBufferList"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable">
            <summary>
            Returns <c>true</c> if and only if the total number of pending bytes (<see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.TotalPendingWriteBytes"/>)
            did not exceed the write watermark of the <see cref="T:DotNetty.Transport.Channels.IChannel"/> and no user-defined writability flag
            (<see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.SetUserDefinedWritability(System.Int32,System.Boolean)"/>) has been set to <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.GetUserDefinedWritability(System.Int32)">
            <summary>
            Returns <c>true</c> if and only if the user-defined writability flag at the specified index is set to
            <c>true</c>.
            </summary>
            <param name="index">The index to check for user-defined writability.</param>
            <returns>
            <c>true</c> if the user-defined writability flag at the specified index is set to <c>true</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.SetUserDefinedWritability(System.Int32,System.Boolean)">
            <summary>
            Sets a user-defined writability flag at the specified index.
            </summary>
            <param name="index">The index where a writability flag should be set.</param>
            <param name="writable">Whether to set the index as writable or not.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.Size">
            <summary>
            Returns the number of flushed messages in this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsEmpty">
            <summary>
            Returns <c>true</c> if there are flushed messages in this <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.BytesBeforeUnwritable">
            <summary>
            Gets the number of bytes that can be written before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> returns <c>false</c>.
            This quantity will always be non-negative. If <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> is already <c>false</c>, then 0 is
            returned.
            </summary>
            <returns>
            The number of bytes that can be written before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> returns <c>false</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.BytesBeforeWritable">
            <summary>
            Gets the number of bytes that must be drained from the underlying buffer before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/>
            returns <c>true</c>. This quantity will always be non-negative. If <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> is already
            <c>true</c>, then 0 is returned.
            </summary>
            <returns>
            The number of bytes that can be written before <see cref="P:DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable"/> returns <c>true</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.ForEachFlushedMessage(DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor)">
            <summary>
            Calls <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor.ProcessMessage(System.Object)"/> for each flushed message in this
            <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer"/> until <see cref="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor.ProcessMessage(System.Object)"/> returns
            <c>false</c> or there are no more flushed messages to process.
            </summary>
            <param name="processor">
            The <see cref="T:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor"/> intance to use to process each flushed message.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.ChannelOutboundBuffer.IMessageProcessor.ProcessMessage(System.Object)">
            <summary>
            Will be called for each flushed message until it either there are no more flushed messages or this method returns <c>false</c>.
            </summary>
            <param name="msg">The message to process.</param>
            <returns><c>true</c> if the given message was successfully processed, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.DefaultChannelConfiguration">
            <summary>
                Shared configuration for SocketAsyncChannel. Provides access to pre-configured resources like ByteBuf allocator and
                IO buffer pools
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.DefaultChannelPipeline.pendingHandlerCallbackHead">
            <summary>
            This is the head of a linked list that is processed by <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.CallHandlerAddedForAllHandlers" /> and so
            process all the pending <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.CallHandlerAdded0(DotNetty.Transport.Channels.AbstractChannelHandlerContext)" />. We only keep the head because it is expected that
            the list is used infrequently and its size is small. Thus full iterations to do insertions is assumed to be
            a good compromised to saving memory and tail management complexity.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.DefaultChannelPipeline.registered">
            <summary>
            Set to <c>true</c> once the <see cref="T:DotNetty.Transport.Channels.AbstractChannel" /> is registered. Once set to <c>true</c>, the
            value will never change.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.ToString">
            <summary>
            Returns the string representation of this pipeline.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.Destroy">
            <summary>
            Removes all handlers from the pipeline one by one from tail (exclusive) to head (exclusive) to trigger
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.HandlerRemoved(DotNetty.Transport.Channels.IChannelHandlerContext)"/>. Note that we traverse up the pipeline <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.DestroyUp(DotNetty.Transport.Channels.AbstractChannelHandlerContext,System.Boolean)"/>
            before traversing down <see cref="M:DotNetty.Transport.Channels.DefaultChannelPipeline.DestroyDown(DotNetty.Common.Concurrency.XThread,DotNetty.Transport.Channels.AbstractChannelHandlerContext,System.Boolean)"/> so that the handlers are removed after all events are
            handled.
            See: https://github.com/netty/netty/issues/3156
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundException(System.Exception)">
            <summary>
            Called once an <see cref="T:System.Exception" /> hits the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" /> without being
            handled by the user in <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultChannelPipeline.OnUnhandledInboundMessage(System.Object)">
            <summary>
            Called once a message hits the end of the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" /> without being handled by the user
            in <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)" />. This method is responsible
            for calling <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)" /> on the given msg at some point.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator">
            <summary>
                Default implementation of <see cref="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator" /> which respects
                <see cref="P:DotNetty.Transport.Channels.IChannelConfiguration.AutoRead" />
                and also prevents overflow.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle`1">
            <summary>Focuses on enforcing the maximum messages per read condition for <see cref="M:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle`1.ContinueReading" />.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle`1.Reset(DotNetty.Transport.Channels.IChannelConfiguration)">
            <summary>Only <see cref="!:IChannelConfiguration.MaxMessagesPerRead" /> is used.</summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.DefaultMessageSizeEstimator.Default">
            <summary>
            Returns the default implementation, which returns <c>0</c> for unknown messages.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.DefaultMessageSizeEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="unknownSize">The size which is returned for unknown messages.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor">
            <summary>
                Create a new instance with an empty pipeline.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor(DotNetty.Transport.Channels.IChannelId)">
            <summary>
                Create a new instance with an empty pipeline with the specified <see cref="T:DotNetty.Transport.Channels.IChannelId" />.
            </summary>
            <param name="channelId">The <see cref="T:DotNetty.Transport.Channels.IChannelId" /> of this channel. </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor(DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
                Create a new instance with the pipeline initialized with the specified handlers.
            </summary>
            <param name="handlers">
                The <see cref="T:DotNetty.Transport.Channels.IChannelHandler" />s that will be added to the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.#ctor(DotNetty.Transport.Channels.IChannelId,System.Boolean,DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>Create a new instance with the pipeline initialized with the specified handlers.</summary>
            <param name="id">The <see cref="T:DotNetty.Transport.Channels.IChannelId" /> of this channel.</param>
            <param name="hasDisconnect">
                <c>false</c> if this <see cref="T:DotNetty.Transport.Channels.IChannel" /> will delegate <see cref="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.DisconnectAsync" />
                to <see cref="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.CloseAsync" />, <c>true</c> otherwise.
            </param>
            <param name="handlers">
                The <see cref="T:DotNetty.Transport.Channels.IChannelHandler" />s that will be added to the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline" />
            </param>
        </member>
        <member name="P:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.InboundMessages">
            <summary>
                Returns the <see cref="T:System.Collections.Generic.Queue`1" /> which holds all of the <see cref="T:System.Object" />s that
                were received by this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.OutboundMessages">
            <summary>
                Returns the <see cref="T:System.Collections.Generic.Queue`1" /> which holds all of the <see cref="T:System.Object" />s that
                were written by this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReadInbound``1">
            <summary>
            Return received data from this <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReadOutbound``1">
            <summary>
            Read data from the outbound. This may return <c>null</c> if nothing is readable.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.RunPendingTasks">
            <summary>
                Run all tasks (which also includes scheduled tasks) that are pending in the <see cref="T:DotNetty.Transport.Channels.IEventLoop" />
                for this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.RunScheduledPendingTasks">
            <summary>
                Run all pending scheduled tasks in the <see cref="T:DotNetty.Transport.Channels.IEventLoop" /> for this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
            <returns>
                The <see cref="T:DotNetty.Common.PreciseTimeSpan" /> when the next scheduled task is ready to run. If no other task is
                scheduled then it will return <see cref="F:DotNetty.Common.PreciseTimeSpan.Zero" />.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.WriteInbound(System.Object[])">
            <summary>
                Write messages to the inbound of this <see cref="T:DotNetty.Transport.Channels.IChannel" />
            </summary>
            <param name="msgs">The messages to be written.</param>
            <returns><c>true</c> if the write operation did add something to the inbound buffer</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.WriteOutbound(System.Object[])">
            <summary>
                Write messages to the outbound of this <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
            <param name="msgs">The messages to be written.</param>
            <returns><c>true</c> if the write operation did add something to the inbound buffer</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.Finish">
            <summary>
                Mark this <see cref="T:DotNetty.Transport.Channels.IChannel" /> as finished. Any further try to write data to it will fail.
            </summary>
            <returns>bufferReadable returns <c>true</c></returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.FinishAndReleaseAll">
            <summary>
            Marks this <see cref="T:DotNetty.Transport.Channels.IChannel"/> as finished and releases all pending message in the inbound and outbound
            buffer. Any futher try to write data to it will fail.
            </summary>
            <returns><c>true</c> if any of the used buffers has something left to read, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.Finish(System.Boolean)">
            <summary>
            Marks this <see cref="T:DotNetty.Transport.Channels.IChannel"/> as finished. Any futher attempt to write data to it will fail.
            </summary>
            <param name="releaseAll">If <c>true</c>, all pending messages in the inbound and outbound buffer are released.</param>
            <returns><c>true</c> if any of the used buffers has something left to read, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReleaseInbound">
            <summary>
            Releases all buffered inbound messages.
            </summary>
            <returns><c>true</c> if any were in the inbound buffer, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.ReleaseOutbound">
            <summary>
            Releases all buffered outbound messages.
            </summary>
            <returns><c>true</c> if any were in the outbound buffer, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.CheckException">
            <summary>
                Check to see if there was any <see cref="T:System.Exception" /> and rethrow if so.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Embedded.EmbeddedChannel.EnsureOpen">
            <summary>
                Ensure the <see cref="T:DotNetty.Transport.Channels.IChannel" /> is open and if not throw an exception.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Embedded.EmbeddedChannelId">
            <summary>
                A dummy <see cref="T:DotNetty.Transport.Channels.IChannelId" /> implementation
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.FixedRecvByteBufAllocator">
            <summary>
                The <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocator" /> that always yields the same buffer
                size prediction. This predictor ignores the feedback from the I/O thread.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.FixedRecvByteBufAllocator.#ctor(System.Int32)">
            <summary>
                Creates a new predictor that always returns the same prediction of
                the specified buffer size.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Groups.IChannelGroup.Name">
            <summary>
                Returns the name of this group.  A group name is purely for helping
                you to distinguish one group from others.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannel.Metadata">
            <summary>
                Return the <see cref="T:DotNetty.Transport.Channels.ChannelMetadata" /> of the <see cref="T:DotNetty.Transport.Channels.IChannel" /> which describe the nature of the
                <see cref="T:DotNetty.Transport.Channels.IChannel" />.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRegistered(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            The <see cref="T:DotNetty.Transport.Channels.IChannel"/> of the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> was registered with its
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ChannelUnregistered(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            The <see cref="T:DotNetty.Transport.Channels.IChannel"/> of the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> was unregistered from its
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ChannelWritabilityChanged(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Gets called once the writable state of a <see cref="T:DotNetty.Transport.Channels.IChannel"/> changed. You can check the state with
            <see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.BindAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)">
            <summary>
            Called once a bind operation is made.
            </summary>
            <param name="context">
            The <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> for which the bind operation is made.
            </param>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to which it should bind.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Called once a connect operation is made.
            </summary>
            <param name="context">
            The <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> for which the connect operation is made.
            </param>
            <param name="remoteAddress">The <see cref="T:System.Net.EndPoint"/> to which it should connect.</param>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> which is used as source on connect.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandler.DisconnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Called once a disconnect operation is made.
            </summary>
            <param name="context">
            The <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> for which the disconnect operation is made.
            </param>
            <returns>An await-able task.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Executor">
            <summary>
            Returns the <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> which is used to execute an arbitrary task.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelHandlerContext.Name">
            <summary>
            The unique name of the <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.
            </summary>
            <remarks>
            The name was used when the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> was added to the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            This name can also be used to access the registered <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> from the
            <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </remarks>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRegistered">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> was registered to its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>. This will result in having the
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRegistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>
            contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>The current <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelUnregistered">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> was unregistered from its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>. This will result in having the
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelUnregistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>
            contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>The current <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.BindAsync(System.Net.EndPoint)">
            <summary>
            Request to bind to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.BindAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to bind to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/> while also binding to the localAddress.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The <see cref="T:System.Net.EndPoint"/> to bind to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.DisconnectAsync">
            <summary>
            Request to disconnect from the remote peer.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.DisconnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelHandlerContext.DeregisterAsync">
            <summary>
            Request to deregister from the previous assigned <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.DeregisterAsync(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.IChannelPipeline">
            <summary>
            A list of <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s which handles or intercepts inbound events and outbound operations of
            a <see cref="T:DotNetty.Transport.Channels.IChannel"/>. <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> implements an advanced form of the
            <a href="http://www.oracle.com/technetwork/java/interceptingfilter-142169.html">Intercepting Filter</a> pattern
            to give a user full control over how an event is handled and how the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in a
            pipeline interact with each other.
            <para>Creation of a pipeline</para>
            <para>Each channel has its own pipeline and it is created automatically when a new channel is created.</para>
            <para>How an event flows in a pipeline</para>
            <para>
            The following diagram describes how I/O events are processed by <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in a
            <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> typically. An I/O event is handled by a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> and is
            forwarded by the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> which handled the event to the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>
            which is placed right next to it. A <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> can also trigger an arbitrary I/O event if
            necessary. To forward or trigger an event, a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> calls the event propagation methods
            defined in <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/>, such as <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRead(System.Object)"/>
            and <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object)"/>.
            </para>
            <para>
                <pre>
                    I/O Request
                    via <see cref="T:DotNetty.Transport.Channels.IChannel"/> or
                    {@link ChannelHandlerContext} 
                    |
                    +---------------------------------------------------+---------------+
                    |                           ChannelPipeline         |               |
                    |                                                  \|/              |
                    |    +----------------------------------------------+----------+    |
                    |    |                   ChannelHandler  N                     |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  |               |
                    |               |                                  \|/              |
                    |    +----------+-----------------------------------+----------+    |
                    |    |                   ChannelHandler N-1                    |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  .               |
                    |               .                                   .               |
                    | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
                    |          [method call]                      [method call]         |
                    |               .                                   .               |
                    |               .                                  \|/              |
                    |    +----------+-----------------------------------+----------+    |
                    |    |                   ChannelHandler  2                     |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  |               |
                    |               |                                  \|/              |
                    |    +----------+-----------------------------------+----------+    |
                    |    |                   ChannelHandler  1                     |    |
                    |    +----------+-----------------------------------+----------+    |
                    |              /|\                                  |               |
                    +---------------+-----------------------------------+---------------+
                    |                                  \|/
                    +---------------+-----------------------------------+---------------+
                    |               |                                   |               |
                    |       [ Socket.read() ]                    [ Socket.write() ]     |
                    |                                                                   |
                    |  Netty Internal I/O Threads (Transport Implementation)            |
                    +-------------------------------------------------------------------+
                </pre>
            </para>
            <para>
            An inbound event is handled by the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in the bottom-up direction as shown on the
            left side of the diagram. An inbound event is usually triggered by the I/O thread on the bottom of the diagram
            so that the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s are notified when the state of a <see cref="T:DotNetty.Transport.Channels.IChannel"/> changes
            (e.g. newly established connections and closed connections) or the inbound data was read from a remote peer. If
            an inbound event goes beyond the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the top of the diagram, it is discarded and
            logged, depending on your loglevel.
            </para>
            <para>
            An outbound event is handled by the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in the top-down direction as shown on the
            right side of the diagram. An outbound event is usually triggered by your code that requests an outbound I/O
            operation, such as a write request and a connection attempt.  If an outbound event goes beyond the
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the bottom of the diagram, it is handled by an I/O thread associated with the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>. The I/O thread often performs the actual output operation such as
            <see cref="M:DotNetty.Transport.Channels.AbstractChannel.WriteAsync(System.Object)"/>.
            </para>
            <para>Forwarding an event to the next handler</para>
            <para>
            As explained briefly above, a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> has to invoke the event propagation methods in
            <see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> to forward an event to its next handler. Those methods include:
                <ul>
                    <li>
                        Inbound event propagation methods:
                        <ul>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRegistered"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelActive"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRead(System.Object)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelReadComplete"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireExceptionCaught(System.Exception)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireUserEventTriggered(System.Object)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelWritabilityChanged"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelInactive"/></li>
                        </ul>
                    </li>
                    <li>
                        Outbound event propagation methods:
                        <ul>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.BindAsync(System.Net.EndPoint)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object)"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.Flush"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.Read"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.DisconnectAsync"/></li>
                            <li><see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.CloseAsync"/></li>
                        </ul>
                    </li>
                </ul>
            </para>
            <para>
                and the following example shows how the event propagation is usually done:
                <code>
                    public class MyInboundHandler : <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/>
                    {
                        public override void ChannelActive(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx)
                        {
                            Console.WriteLine("Connected!");
                            ctx.FireChannelActive();
                        }
                    }
            
                    public class MyOutboundHandler : <see cref="T:DotNetty.Transport.Channels.ChannelHandlerAdapter"/>
                    {
                        public override async Task CloseAsync(<see cref="T:DotNetty.Transport.Channels.IChannelHandlerContext"/> ctx)
                        {
                            Console.WriteLine("Closing...");
                            await ctx.CloseAsync();
                        }
                    }
                </code>
            </para>
            <para>Building a pipeline</para>
            <para>
            A user is supposed to have one or more <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s in a pipeline to receive I/O events
            (e.g. read) and to request I/O operations (e.g. write and close).  For example, a typical server will have the
            following handlers in each channel's pipeline, but your mileage may vary depending on the complexity and
            characteristics of the protocol and business logic:
                <ol>
                    <li>Protocol Decoder - translates binary data (e.g. <see cref="T:DotNetty.Buffers.IByteBuffer"/>) into a Java object.</li>
                    <li>Protocol Encoder - translates a Java object into binary data.</li>
                    <li>Business Logic Handler - performs the actual business logic (e.g. database access).</li>
                </ol>
            </para>
            <para>
                and it could be represented as shown in the following example:
                <code>
                    static readonly <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> group = new <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>();
                    ...
                    <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> pipeline = ch.Pipeline;
                    pipeline.AddLast("decoder", new MyProtocolDecoder());
                    pipeline.AddLast("encoder", new MyProtocolEncoder());
            
                    // Tell the pipeline to run MyBusinessLogicHandler's event handler methods
                    // in a different thread than an I/O thread so that the I/O thread is not blocked by
                    // a time-consuming task.
                    // If your business logic is fully asynchronous or finished very quickly, you don't
                    // need to specify a group.
                    pipeline.AddLast(group, "handler", new MyBusinessLogicHandler());
                </code>
            </para>
            <para>Thread safety</para>
            <para>
            An <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> can be added or removed at any time because an <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>
            is thread safe. For example, you can insert an encryption handler when sensitive information is about to be
            exchanged, and remove it after the exchange.
            </para>
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts an <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the first position of this pipeline.
            </summary>
            <param name="name">
            The name of the handler to insert first. Pass <c>null</c> to let the name auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to insert first.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the first position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="name">
            The name of the handler to insert first. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to insert first.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Appends an <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the last position of this pipeline.
            </summary>
            <param name="name">
            The name of the handler to append. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Appends a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> at the last position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="name">
            The name of the handler to append. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddBefore(System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> before an existing handler of this pipeline.
            </summary>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddBefore(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> before an existing handler of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to append.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddAfter(System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> after an existing handler of this pipeline.
            </summary>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The handler to insert after.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddAfter(DotNetty.Common.Concurrency.IEventExecutorGroup,System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Inserts a <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> after an existing handler of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handler"/>'s event handler methods.
            </param>
            <param name="baseName">The name of the existing handler.</param>
            <param name="name">
            The name of the new handler being appended. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="handler">The handler to insert after.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="name"/> already exists, or if no match was found for the
            given <paramref name="baseName"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">Thrown if the specified handler is <c>null</c>.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the first position of this pipeline.
            </summary>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddFirst(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the first position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handlers"/>' event handler methods.
            </param>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the last position of this pipeline.
            </summary>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.AddLast(DotNetty.Common.Concurrency.IEventExecutorGroup,DotNetty.Transport.Channels.IChannelHandler[])">
            <summary>
            Inserts multiple <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s at the last position of this pipeline.
            </summary>
            <param name="group">
            The <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup"/> which invokes the <paramref name="handlers"/>' event handler methods.
            </param>
            <param name="handlers">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>s to insert.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Remove(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Removes the specified <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> from this pipeline.
            </summary>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to remove.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the specified handler was not found.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Remove(System.String)">
            <summary>
            Removes the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with the specified name from this pipeline.
            </summary>
            <param name="name">The name under which the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> was stored.</param>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if there's no such handler with the specified name in this pipeline.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Remove``1">
            <summary>
            Removes the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type from this pipeline.
            </summary>
            <typeparam name="T">The type of handler to remove.</typeparam>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if there's no handler of the specified type in this pipeline.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.RemoveFirst">
            <summary>
            Removes the first <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this pipeline is empty.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.RemoveLast">
            <summary>
            Removes the last <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The removed <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this pipeline is empty.</exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Replace(DotNetty.Transport.Channels.IChannelHandler,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Replaces the specified <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with a new handler in this pipeline.
            </summary>
            <param name="oldHandler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be replaced.</param>
            <param name="newName">
            The name of the new handler being inserted. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="newHandler">The new <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be inserted.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="newName"/> already exists, or if the
            <paramref name="oldHandler"/> was not found.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Replace(System.String,System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Replaces the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified name with a new handler in this pipeline.
            </summary>
            <param name="oldName">The name of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be replaced.</param>
            <param name="newName">
            The name of the new handler being inserted. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="newHandler">The new <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be inserted.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> that was replaced.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="newName"/> already exists, or if no match was found for
            the given <paramref name="oldName"/>.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Replace``1(System.String,DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Replaces the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type with a new handler in this pipeline.
            </summary>
            <typeparam name="T">The type of the handler to be removed.</typeparam>
            <param name="newName">
            The name of the new handler being inserted. Pass <c>null</c> to let the name be auto-generated.
            </param>
            <param name="newHandler">The new <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> to be inserted.</param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> that was replaced.</returns>
            <exception cref="T:System.ArgumentException">
            Thrown if an entry with the same <paramref name="newName"/> already exists, or if no match was found for
            the given type.
            </exception>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.First">
            <summary>
            Returns the first <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The first handler in the pipeline, or <c>null</c> if the pipeline is empty.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FirstContext">
            <summary>
            Returns the context of the first <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>
            The context of the first handler in the pipeline, or <c>null</c> if the pipeline is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Last">
            <summary>
            Returns the last <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>The last handler in the pipeline, or <c>null</c> if the pipeline is empty.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.LastContext">
            <summary>
            Returns the context of the last <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <returns>
            The context of the last handler in the pipeline, or <c>null</c> if the pipeline is empty.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Get(System.String)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with the specified name in this pipeline.
            </summary>
            <param name="name">The name of the desired <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/>.</param>
            <returns>
            The handler with the specified name, or <c>null</c> if there's no such handler in this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Get``1">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type in this pipeline.
            </summary>
            <typeparam name="T">The type of handler to retrieve.</typeparam>
            <returns>
            The handler with the specified type, or <c>null</c> if there's no such handler in this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Context(DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Returns the context object of the specified <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in this pipeline.
            </summary>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> whose context should be retrieved.</param>
            <returns>
            The context object of the specified handler, or <c>null</c> if there's no such handler in this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Context(System.String)">
            <summary>
            Returns the context object of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> with the specified name in this pipeline.
            </summary>
            <param name="name">The name of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> whose context should be retrieved.</param>
            <returns>
            The context object of the handler with the specified name, or <c>null</c> if there's no such handler in
            this pipeline.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Context``1">
            <summary>
            Returns the context object of the <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> of the specified type in this pipeline.
            </summary>
            <typeparam name="T">The type of <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> whose context should be retrieved.</typeparam>
            <returns>
            The context object of the handler with the specified type, or <c>null</c> if there's no such handler in
            this pipeline.
            </returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.IChannelPipeline.Channel">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.IChannel" /> that this pipeline is attached to.
            Returns <c>null</c> if this pipeline is not attached to any channel yet.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelRegistered">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> was registered to its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRegistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelUnregistered">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> was unregistered from its <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelUnregistered(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelActive">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> is active now, which means it is connected.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelActive(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelInactive">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> is inactive now, which means it is closed.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelInactive(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireExceptionCaught(System.Exception)">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> received an <see cref="T:System.Exception"/> in one of its inbound operations.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ExceptionCaught(DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> that was caught.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireUserEventTriggered(System.Object)">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> received an user defined event.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="evt">The user-defined event that was triggered.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelRead(System.Object)">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> received a message.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="msg">The message that was received.</param>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelReadComplete">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.IChannel"/> completed a message after reading it.
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method
            called of the next <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.FireChannelWritabilityChanged">
            <summary>
            Triggers an <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelWritabilityChanged(DotNetty.Transport.Channels.IChannelHandlerContext)"/> event to the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.BindAsync(System.Net.EndPoint)">
            <summary>
            Request to bind to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.BindAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.ConnectAsync(System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Request to connect to the given <see cref="T:System.Net.EndPoint"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <param name="remoteAddress">The remote <see cref="T:System.Net.EndPoint"/> to connect to.</param>
            <param name="localAddress">The local <see cref="T:System.Net.EndPoint"/> to bind.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.DisconnectAsync">
            <summary>
            Request to disconnect from the remote peer.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.DisconnectAsync(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.CloseAsync">
            <summary>
            Request to close the <see cref="T:DotNetty.Transport.Channels.IChannel"/>. After it is closed it is not possible to reuse it again.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.CloseAsync(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.DeregisterAsync">
            <summary>
            Request to deregister the <see cref="T:DotNetty.Transport.Channels.IChannel"/> bound this <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> from the
            previous assigned <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/>.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.DeregisterAsync(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Read">
            <summary>
            Request to Read data from the <see cref="T:DotNetty.Transport.Channels.IChannel"/> into the first inbound buffer, triggers an
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> event if data was read, and triggers a
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.ChannelReadComplete(DotNetty.Transport.Channels.IChannelHandlerContext)"/> event so the handler can decide whether to continue
            reading. If there's a pending read operation already, this method does nothing.
            <para>
            This will result in having the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.Read(DotNetty.Transport.Channels.IChannelHandlerContext)"/> method called of the next
            <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> contained in the  <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> of the
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </para>
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.WriteAsync(System.Object)">
            <summary>
            Request to write a message via this <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            This method will not request to actual flush, so be sure to call <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.Flush"/>
            once you want to request to flush all pending data to the actual transport.
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.Flush">
            <summary>
            Request to flush all pending messages.
            </summary>
            <returns>This <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IChannelPipeline.WriteAndFlushAsync(System.Object)">
            <summary>
            Shortcut for calling both <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.WriteAsync(System.Object)"/> and <see cref="M:DotNetty.Transport.Channels.IChannelPipeline.Flush"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IEventLoop">
            <summary>
            <see cref="T:DotNetty.Common.Concurrency.IEventExecutor"/> specialized to handle I/O operations of assigned <see cref="T:DotNetty.Transport.Channels.IChannel"/>s.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IEventLoop.Parent">
            <summary>
            Parent <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IEventLoopGroup">
            <inheritdoc />
            <summary>
            <see cref="T:DotNetty.Common.Concurrency.IEventExecutorGroup" /> specialized for handling <see cref="T:DotNetty.Transport.Channels.IEventLoop" />s.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IEventLoopGroup.GetNext">
            <summary>
            Returns <see cref="T:DotNetty.Transport.Channels.IEventLoop"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IEventLoopGroup.RegisterAsync(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Register the <see cref="T:DotNetty.Transport.Channels.IChannel"/> for this event loop.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> to register.</param>
            <returns>The register task.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator">
            <summary>
                <see cref="T:DotNetty.Transport.Channels.IRecvByteBufAllocator" /> that limits the number of read operations that will be attempted when a read
                operation
                is attempted by the event loop.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.IMaxMessagesRecvByteBufAllocator.MaxMessagesPerRead">
            <summary>
                Gets or sets the maximum number of messages to read per read loop.
                If this value is greater than 1, an event loop might attempt to read multiple times to procure multiple messages.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IMessageSizeEstimator.NewHandle">
            <summary>
                Creates a new handle. The handle provides the actual operations.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IMessageSizeEstimatorHandle.Size(System.Object)">
            <summary>
            Calculates the size of the given message.
            </summary>
            <param name="msg">The message for which the size should be calculated.</param>
            <returns>The size in bytes. The returned size must be >= 0</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.IRecvByteBufAllocator">
            <summary>
                Allocates a new receive buffer whose capacity is probably large enough to read all inbound data and small enough
                not to waste its space.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocator.NewHandle">
            <summary>
                Creates a new handle.  The handle provides the actual operations and keeps the internal information which is
                required for predicting an optimal buffer capacity.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Allocate(DotNetty.Buffers.IByteBufferAllocator)">
            <summary>
                Creates a new receive buffer whose capacity is probably large enough to read all inbound data and small
                enough not to waste its space.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Guess">
            <summary>
                Similar to <see cref="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Allocate(DotNetty.Buffers.IByteBufferAllocator)" /> except that it does not allocate anything but just tells the
                capacity.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Reset(DotNetty.Transport.Channels.IChannelConfiguration)">
            <summary>
                Reset any counters that have accumulated and recommend how many messages/bytes should be read for the next
                read loop.
                <p>
                    This may be used by <see cref="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ContinueReading" /> to determine if the read operation should complete.
                </p>
                This is only ever a hint and may be ignored by the implementation.
            </summary>
            <param name="config">The channel configuration which may impact this object's behavior.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.IncMessagesRead(System.Int32)">
            <summary>Increment the number of messages that have been read for the current read loop.</summary>
            <param name="numMessages">The amount to increment by.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.LastBytesRead">
            <summary>
                Get or set the bytes that have been read for the last read operation.
                This may be used to increment the number of bytes that have been read.
            </summary>
            <remarks>
                Returned value may be negative if an read error
                occurs. If a negative value is seen it is expected to be return on the next set to
                <see cref="P:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.LastBytesRead" />. A negative value will signal a termination condition enforced externally
                to this class and is not required to be enforced in <see cref="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ContinueReading" />.
            </remarks>
        </member>
        <member name="P:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.AttemptedBytesRead">
            <summary>Get or set how many bytes the read operation will (or did) attempt to read.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ContinueReading">
            <summary>Determine if the current read loop should should continue.</summary>
            <returns><c>true</c> if the read loop should continue reading. <c>false</c> if the read loop is complete.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.ReadComplete">
            <summary>Signals read completion.</summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.IServerChannel">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> that accepts an incoming connection attempt and creates its child
            <see cref="T:DotNetty.Transport.Channels.IChannel"/>s by accepting them. <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel"/> is a good example.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Local.LocalChannel">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannel"/> for the local transport.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Local.LocalServerChannel">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IServerChannel"/> for the local transport which allows in VM communication.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Local.LocalServerChannel.NewLocalChannel(DotNetty.Transport.Channels.Local.LocalChannel)">
            <summary>
            A factory method for <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/>s. Users may override it to create custom instances of <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/>s.
            </summary>
            <param name="peer">An existing <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/> that will act as a peer for the new channel.</param>
            <returns>The newly created <see cref="T:DotNetty.Transport.Channels.Local.LocalChannel"/> instance.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IEventLoopGroup"/> backed by a set of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/> instances.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.MultithreadEventLoopGroup.TerminationCompletion">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor(System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor(System.Func{DotNetty.Transport.Channels.IEventLoopGroup,DotNetty.Transport.Channels.IEventLoop})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.#ctor(System.Func{DotNetty.Transport.Channels.IEventLoopGroup,DotNetty.Transport.Channels.IEventLoop},System.Int32)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.MultithreadEventLoopGroup"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.DotNetty#Transport#Channels#IEventLoopGroup#GetNext">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.GetNext">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Transport.Channels.MultithreadEventLoopGroup.ShutdownGracefullyAsync(System.TimeSpan,System.TimeSpan)">
            <inheritdoc cref="M:DotNetty.Common.Concurrency.IEventExecutorGroup.ShutdownGracefullyAsync" />
        </member>
        <member name="T:DotNetty.Transport.Channels.PendingWriteQueue">
            <summary>
            A queue of write operations which are pending for later execution. It also updates the writability of the
            associated <see cref="T:DotNetty.Transport.Channels.IChannel"/> (<see cref="P:DotNetty.Transport.Channels.IChannel.IsWritable"/>), so that the pending write operations are
            also considered to determine the writability.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.PendingWriteQueue.IsEmpty">
            <summary>
            Returns <c>true</c> if there are no pending write operations left in this queue.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.PendingWriteQueue.Size">
            <summary>
            Returns the number of pending write operations.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.Add(System.Object)">
            <summary>
            Adds the given message to this <see cref="T:DotNetty.Transport.Channels.PendingWriteQueue"/>.
            </summary>
            <param name="msg">The message to add to the <see cref="T:DotNetty.Transport.Channels.PendingWriteQueue"/>.</param>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndFailAll(System.Exception)">
            <summary>
            Removes all pending write operations, and fail them with the given <see cref="T:System.Exception"/>. The messages
            will be released via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> to fail with.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndFail(System.Exception)">
            <summary>
            Remove a pending write operation and fail it with the given <see cref="T:System.Exception"/>. The message will be
            released via <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <param name="cause">The <see cref="T:System.Exception"/> to fail with.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndWriteAllAsync">
            <summary>
            Removes all pending write operation and performs them via <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object)"/>
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.RemoveAndWriteAsync">
            <summary>
            Removes a pending write operation and performs it via <see cref="M:DotNetty.Transport.Channels.IChannelHandlerContext.WriteAsync(System.Object)"/>.
            </summary>
            <returns>An await-able task.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.PendingWriteQueue.Remove">
            <summary>
            Removes a pending write operation and releases it's message via
            <see cref="M:DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)"/>.
            </summary>
            <returns>
            The <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource" /> of the pending write, or <c>null</c> if the queue is empty.
            </returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.PendingWriteQueue.Current">
            <summary>
            Return the current message, or <c>null</c> if the queue is empty.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.PendingWriteQueue.PendingWrite">
            <summary>
            Holds all meta-data and constructs the linked-list structure.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.Remove(`0)">
            <summary>
            Removes the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> from this <see cref="T:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2"/>.
            </summary>
            <param name="key">The key to remove. Must not be null.</param>
            <returns><c>true</c> if removed, otherwise <c>false</c>.</returns>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.Count">
            <summary>
            Returns the number of <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>s currently in this <see cref="T:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.IsEmpty">
            <summary>
            Returns <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2"/> is empty, otherwise <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.AbstractChannelPoolMap`2.NewPool(`0)">
            <summary>
            Called once a new <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> needs to be created as none exists yet for the <paramref name="key"/>.
            </summary>
            <param name="key">The <typeparamref name="TKey"/> to create a new <typeparamref name="TPool"/> for.</param>
            <returns>The new <typeparamref name="TPool"/> corresponding to the given <typeparamref name="TKey"/>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.ChannelActiveHealthChecker">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> implementation that checks if <see cref="P:DotNetty.Transport.Channels.IChannel.Active"/> returns <c>true</c>.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.FixedChannelPool">
            <summary>
            An <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementation that takes another <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementation and
            enforces a maximum number of concurrent connections.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction.New">
            <summary>
            Creates a new connection when the timeout is detected.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction.Fail">
            <summary>
            Fails the <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> of the acquire call with a <see cref="T:System.TimeoutException"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance using the <see cref="T:DotNetty.Transport.Channels.Pool.ChannelActiveHealthChecker"/>.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction,System.TimeSpan,System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="action">
            The <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> to use or <c>null</c> if none should be used. In this case,
            <paramref name="acquireTimeout"/> must also be <c>null</c>.
            </param>
            <param name="acquireTimeout">
            A <see cref="T:System.TimeSpan"/> after which an pending acquire must complete, or the
            <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> takes place.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction,System.TimeSpan,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="action">
            The <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> to use or <c>null</c> if none should be used. In this case,
            <paramref name="acquireTimeout"/> must also be <c>null</c>.
            </param>
            <param name="acquireTimeout">
            A <see cref="T:System.TimeSpan"/> after which an pending acquire must complete, or the
            <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> takes place.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
            <param name="releaseHealthCheck">If <c>true</c>, will check channel health before offering it back.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.FixedChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction,System.TimeSpan,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="action">
            The <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> to use or <c>null</c> if none should be used. In this case,
            <paramref name="acquireTimeout"/> must also be <c>null</c>.
            </param>
            <param name="acquireTimeout">
            A <see cref="T:System.TimeSpan"/> after which an pending acquire must complete, or the
            <see cref="T:DotNetty.Transport.Channels.Pool.FixedChannelPool.AcquireTimeoutAction"/> takes place.
            </param>
            <param name="maxConnections">
            The number of maximal active connections. Once this is reached, new attempts to acquire an
            <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be delayed until a connection is returned to the pool again.
            </param>
            <param name="maxPendingAcquires">
            The maximum number of pending acquires. Once this is exceeded, acquire attempts will be failed.
            </param>
            <param name="releaseHealthCheck">If <c>true</c>, will check channel health before offering it back.</param>
            <param name="lastRecentUsed">
            If <c>true</c>, <see cref="T:DotNetty.Transport.Channels.IChannel"/> selection will be LIFO. If <c>false</c>, it will be FIFO.
            </param>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker">
            <summary>
            Called before an <see cref="T:DotNetty.Transport.Channels.IChannel"/> will be returned via <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.AcquireAsync"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelHealthChecker.IsHealthyAsync(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Checks if the given channel is healthy (which means it can be used). This method will be called by the
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> of the given <see cref="T:DotNetty.Transport.Channels.IChannel"/>
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> to check for healthiness.</param>
            <returns><c>true</c> if the given <see cref="T:DotNetty.Transport.Channels.IChannel"/> is healthy, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelPool">
            <summary>
            Allows the acquisition and release of <see cref="T:DotNetty.Transport.Channels.IChannel"/> instances, and so act as a pool of these.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPool.AcquireAsync">
            <summary>
            Acquires an <see cref="T:DotNetty.Transport.Channels.IChannel"/> from this <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            <para>
            It is important that an acquired <see cref="T:DotNetty.Transport.Channels.IChannel"/> is always released to the pool again via the
            <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.ReleaseAsync(DotNetty.Transport.Channels.IChannel)"/> method, even if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> is explicitly closed.
            </para>
            </summary>
            <returns>The aquired <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPool.ReleaseAsync(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Releases a previously aquired <see cref="T:DotNetty.Transport.Channels.IChannel"/> from this <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>, allowing it to
            be aquired again by another caller.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance to be released.</param>
            <returns>
            <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was successfully released, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler">
            <summary>
            Handler which is called for various actions done by the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolHandler.ChannelReleased(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Called once a <see cref="T:DotNetty.Transport.Channels.IChannel"/> was released by calling <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.ReleaseAsync(DotNetty.Transport.Channels.IChannel)"/>.
            This method will be called by the <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> of the <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance which was released.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolHandler.ChannelAcquired(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Called once a <see cref="T:DotNetty.Transport.Channels.IChannel"/> was acquired by calling <see cref="M:DotNetty.Transport.Channels.Pool.IChannelPool.AcquireAsync"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance which was aquired.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolHandler.ChannelCreated(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Called once a new <see cref="T:DotNetty.Transport.Channels.IChannel"/> is created in the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> instance which was aquired.</param>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2">
            <summary>
            Allows the mapping of <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementations to a specific key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TPool">The type of the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.</typeparam>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2.Get(`0)">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> for the <paramref name="key"/>. This will never return <c>null</c>,
            but create a new <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> if non exists for they requested <paramref name="key"/>.
            Please note that <c>null</c> keys are not allowed.
            </summary>
            <param name="key">The key for the desired <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/></param>
            <returns>The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> for the specified <paramref name="key"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2.Contains(`0)">
            <summary>
            Checks whether the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2"/> contains an <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> for the
            given <paramref name="key"/>. Please note that <c>null</c> keys are not allowed.
            </summary>
            <param name="key">The key to search the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolMap`2"/> for.</param>
            <returns><c>true</c> if a <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> exists for the given <paramref name="key"/>, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool">
            <summary>
            Simple <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/> implementation which will create new <see cref="T:DotNetty.Transport.Channels.IChannel"/>s if someone tries to acquire
            a <see cref="T:DotNetty.Transport.Channels.IChannel"/> but none is in the pool atm. No limit on the maximal concurrent <see cref="T:DotNetty.Transport.Channels.IChannel"/>s is enforced.
            This implementation uses LIFO order for <see cref="T:DotNetty.Transport.Channels.IChannel"/>s in the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance using the <see cref="T:DotNetty.Transport.Channels.Pool.ChannelActiveHealthChecker"/>.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="releaseHealthCheck">
            If <c>true</c>, will check channel health before offering back. Otherwise, channel health is only checked
            at acquisition time.
            </param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.#ctor(DotNetty.Transport.Bootstrapping.Bootstrap,DotNetty.Transport.Channels.Pool.IChannelPoolHandler,DotNetty.Transport.Channels.Pool.IChannelHealthChecker,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Pool.SimpleChannelPool"/> instance.
            </summary>
            <param name="bootstrap">The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> that is used for connections.</param>
            <param name="handler">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </param>
            <param name="healthChecker">
            The <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if a <see cref="T:DotNetty.Transport.Channels.IChannel"/> is still
            healthy when obtained from the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPool"/>.
            </param>
            <param name="releaseHealthCheck">
            If <c>true</c>, will check channel health before offering back. Otherwise, channel health is only checked
            at acquisition time.
            </param>
            <param name="lastRecentUsed">
            If <c>true</c>, <see cref="T:DotNetty.Transport.Channels.IChannel"/> selection will be LIFO. If <c>false</c>, it will be FIFO.
            </param>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.Bootstrap">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> this pool will use to open new connections. 
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.Handler">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelPoolHandler"/> that will be notified for the different pool actions.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.HealthChecker">
            <summary>
            Returns the <see cref="T:DotNetty.Transport.Channels.Pool.IChannelHealthChecker"/> that will be used to check if an <see cref="T:DotNetty.Transport.Channels.IChannel"/> is healthy.
            </summary>
        </member>
        <member name="P:DotNetty.Transport.Channels.Pool.SimpleChannelPool.ReleaseHealthCheck">
            <summary>
            Indicates whether this pool will check the health of channels before offering them back into the pool.
            Returns <c>true</c> if this pool will check the health of channels before offering them back into the pool, or
            <c>false</c> if channel health is only checked at acquisition time.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.ConnectChannel(DotNetty.Transport.Bootstrapping.Bootstrap)">
            <summary>
            Bootstrap a new <see cref="T:DotNetty.Transport.Channels.IChannel"/>. The default implementation uses
            <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync"/>, sub-classes may override this.
            </summary>
            <param name="bs">
            The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> instance to use to bootstrap a new <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            The <see cref="T:DotNetty.Transport.Bootstrapping.Bootstrap"/> passed here is cloned via
            <see cref="M:DotNetty.Transport.Bootstrapping.Bootstrap.Clone"/>, so it is safe to modify.
            </param>
            <returns>The newly connected <see cref="T:DotNetty.Transport.Channels.IChannel"/>.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.DoHealthCheckOnRelease(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Releases the channel back to the pool only if the channel is healthy.
            </summary>
            <param name="channel">The <see cref="T:DotNetty.Transport.Channels.IChannel"/> to put back to the pool.</param>
            <returns>
            <c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was healthy, released, and offered back to the pool.
            <c>false</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> was NOT healthy and was simply released.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryPollChannel(DotNetty.Transport.Channels.IChannel@)">
            <summary>
            Polls an <see cref="T:DotNetty.Transport.Channels.IChannel"/> out of the internal storage to reuse it.
            </summary>
            <remarks>
            Sub-classes may override <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryPollChannel(DotNetty.Transport.Channels.IChannel@)"/> and <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryOfferChannel(DotNetty.Transport.Channels.IChannel)"/>.
            Be aware that implementations of these methods needs to be thread-safe!
            </remarks>
            <param name="channel">
            An output parameter that will contain the <see cref="T:DotNetty.Transport.Channels.IChannel"/> obtained from the pool.
            </param>
            <returns>
            <c>true</c> if an <see cref="T:DotNetty.Transport.Channels.IChannel"/> was retrieved from the pool, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryOfferChannel(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Offers a <see cref="T:DotNetty.Transport.Channels.IChannel"/> back to the internal storage. This will return 
            </summary>
            <remarks>
            Sub-classes may override <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryPollChannel(DotNetty.Transport.Channels.IChannel@)"/> and <see cref="M:DotNetty.Transport.Channels.Pool.SimpleChannelPool.TryOfferChannel(DotNetty.Transport.Channels.IChannel)"/>.
            Be aware that implementations of these methods needs to be thread-safe!
            </remarks>
            <param name="channel"></param>
            <returns><c>true</c> if the <see cref="T:DotNetty.Transport.Channels.IChannel"/> could be added, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.SingleThreadEventLoop">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.IEventLoop"/> implementation based on <see cref="T:DotNetty.Common.Concurrency.SingleThreadEventExecutor"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(System.String)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup,System.String)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup,System.String,System.TimeSpan)">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(System.String,System.TimeSpan,DotNetty.Common.Internal.IQueue{DotNetty.Common.Concurrency.IRunnable})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.#ctor(DotNetty.Transport.Channels.IEventLoopGroup,System.String,System.TimeSpan,DotNetty.Common.Internal.IQueue{DotNetty.Common.Concurrency.IRunnable})">
            <summary>Creates a new instance of <see cref="T:DotNetty.Transport.Channels.SingleThreadEventLoop"/>.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.SingleThreadEventLoop.RegisterAsync(DotNetty.Transport.Channels.IChannel)">
            <inheritdoc />
        </member>
        <member name="P:DotNetty.Transport.Channels.SingleThreadEventLoop.Parent">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel"/> base class for <see cref="T:DotNetty.Transport.Channels.IChannel"/>s that operate on bytes.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel.#ctor(DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>Create a new instance</summary>
            <param name="parent">the parent <see cref="T:DotNetty.Transport.Channels.IChannel"/> by which this instance was created. May be <c>null</c></param>
            <param name="socket">the underlying <see cref="T:System.Net.Sockets.Socket"/> on which it operates</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel.DoReadBytes(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Reads bytes into the given <see cref="T:DotNetty.Buffers.IByteBuffer"/> and returns the number of bytes that were read.
            </summary>
            <param name="buf">The <see cref="T:DotNetty.Buffers.IByteBuffer"/> to read bytes into.</param>
            <returns>The number of bytes that were read into the buffer.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel.DoWriteBytes(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Writes bytes from the given <see cref="T:DotNetty.Buffers.IByteBuffer"/> to the underlying <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="buf">The <see cref="T:DotNetty.Buffers.IByteBuffer"/> from which the bytes should be written.</param>
            <returns>The number of bytes that were written from the buffer.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.ClearReadPending">
            <summary>
                Set read pending to <c>false</c>.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.ResetState(DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.StateFlags)">
            <returns>state before modification</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.OnIoCompleted(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <remarks>PORT NOTE: matches behavior of NioEventLoop.processSelectedKey</remarks>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.ISocketChannelUnsafe.FinishConnect(DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation)">
            <summary>
                Finish connect
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.ISocketChannelUnsafe.FinishRead(DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation)">
            <summary>
                Read from underlying {@link SelectableChannel}
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.DoConnect(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
                Connect to the remote peer
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.DoFinishConnect(DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation)">
            <summary>
                Finish the connect
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel">
            <summary>
            <see cref="T:DotNetty.Transport.Channels.Sockets.AbstractSocketChannel"/> base class for <see cref="T:DotNetty.Transport.Channels.IChannel"/>s that operate on messages.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.#ctor(DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>
            Creates a new <see cref="T:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel"/> instance.
            </summary>
            <param name="parent">The parent <see cref="T:DotNetty.Transport.Channels.IChannel"/>. Pass <c>null</c> if there's no parent.</param>
            <param name="socket">The <see cref="T:System.Net.Sockets.Socket"/> used by the <see cref="T:DotNetty.Transport.Channels.IChannel"/> for communication.</param>
        </member>
        <member name="P:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.ContinueOnWriteError">
            <summary>
            Returns <c>true</c> if we should continue the write loop on a write error.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.DoReadMessages(System.Collections.Generic.List{System.Object})">
            <summary>
            Reads messages into the given list and returns the amount which was read.
            </summary>
            <param name="buf">The list into which message objects should be inserted.</param>
            <returns>The number of messages which were read.</returns>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.DoWriteMessage(System.Object,DotNetty.Transport.Channels.ChannelOutboundBuffer)">
            <summary>
            Writes a message to the underlying <see cref="T:DotNetty.Transport.Channels.IChannel"/>.
            </summary>
            <param name="msg">The message to be written.</param>
            <param name="input">The destination channel buffer for the message.</param>
            <returns><c>true</c> if the message was successfully written, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent">
            <summary>
            Special event which will be fired and passed to the <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/>
            methods once the input of an <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel"/> was shutdown and the
            <see cref="P:DotNetty.Transport.Channels.Sockets.ISocketChannelConfiguration.AllowHalfClosure"/> property returns <c>true</c>.
            </summary>
        </member>
        <member name="F:DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent.Instance">
            <summary>
            Singleton instance to use.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.DefaultServerSocketChannelConfig">
            <summary>
            The default <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannelConfiguration"/> implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.DefaultServerSocketChannelConfig.#ctor(DotNetty.Transport.Channels.Sockets.IServerSocketChannel,System.Net.Sockets.Socket)">
            <summary>
                Creates a new instance.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.DefaultSocketChannelConfiguration">
            <summary>
            The default <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannelConfiguration"/> implementation.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel">
            <summary>
            A TCP/IP <see cref="T:DotNetty.Transport.Channels.IServerChannel"/> which accepts incoming TCP/IP connections.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel">
            <summary>
                A <see cref="T:DotNetty.Transport.Channels.Sockets.IServerSocketChannel" /> implementation which uses Socket-based implementation to accept new
                connections.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor">
            <summary>
                Create a new instance
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>
                Create a new instance
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>
                Create a new instance using the given <see cref="T:System.Net.Sockets.Socket"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Transport.Channels.Sockets.TcpSocketChannel">
            <summary>
                <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" /> which uses Socket-based implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor">
            <summary>Create a new instance</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>Create a new instance</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>Create a new instance using the given <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" />.</summary>
        </member>
        <member name="M:DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>Create a new instance</summary>
            <param name="parent">
                the <see cref="T:DotNetty.Transport.Channels.IChannel" /> which created this instance or <c>null</c> if it was created by the
                user
            </param>
            <param name="socket">the <see cref="T:DotNetty.Transport.Channels.Sockets.ISocketChannel" /> which will be used</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Util.SafeSetSuccess(DotNetty.Common.Concurrency.TaskCompletionSource,DotNetty.Common.Internal.Logging.IInternalLogger)">
            <summary>
            Marks the specified <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> as success. If the
            <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> is done already, logs a message.
            </summary>
            <param name="promise">The <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> to complete.</param>
            <param name="logger">The <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/> to use to log a failure message.</param>
        </member>
        <member name="M:DotNetty.Transport.Channels.Util.SafeSetFailure(DotNetty.Common.Concurrency.TaskCompletionSource,System.Exception,DotNetty.Common.Internal.Logging.IInternalLogger)">
            <summary>
            Marks the specified <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> as failure. If the
            <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> is done already, log a message.
            </summary>
            <param name="promise">The <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> to complete.</param>
            <param name="cause">The <see cref="T:System.Exception"/> to fail the <see cref="T:DotNetty.Common.Concurrency.TaskCompletionSource"/> with.</param>
            <param name="logger">The <see cref="T:DotNetty.Common.Internal.Logging.IInternalLogger"/> to use to log a failure message.</param>
        </member>
    </members>
</doc>
